"""
A clock tick is a record of time passing.
This is used to update the protocol's stats at regular intervals.
"""
type ClockTick @entity(immutable: true) {
  "truncated timestamp + tick period"
  id: Bytes!

  """
  Duration of the snapshot period in seconds.
  Available periods:
  - 15 minutes: 900
  - 1 day: 86400
  """
  period: BigInt!
  "Timestamp the tick was initiated at, rounded to period"
  roundedTimestamp: BigInt!
  "Actual timestamp tick was initiated at"
  timestamp: BigInt!
}

"""
A investor is an address that interacts with our protocol.
"""
type Investor @entity {
  "User address"
  id: Bytes!

  "The investor's balances in all the tracked vaults"
  positions: [InvestorPosition!]! @derivedFrom(field: "investor")
}

"""
A token is a representation of a fungible asset on the blockchain
as specified by the ERC20 standard.
"""
type Token @entity(immutable: true) {
  "token address"
  id: Bytes!

  "The token symbol"
  symbol: String
  "The token name"
  name: String
  "The number of decimals the token uses"
  decimals: BigInt!
}

enum VaultLifecycle {
  "The vault is in the process of being initialized"
  INITIALIZING
  "The vault is able to accept deposits and earn yield"
  RUNNING
  "A vault can be paused for a variety of reasons, this is always to protect investors funds"
  PAUSED
}

enum VaultUnderlyingPlatform {
  PENDLE_EQUILIBRIA
  BALANCER_AURA
  MENDI
  AERODROME
  CURVE
  LYNEX_GAMMA
}

"""
A Beefy vault
"""
type BeefyVault @entity {
  "Vault address"
  id: Bytes!

  "Moo token address"
  sharesToken: Token!

  "Input lp token address"
  underlyingToken: Token!

  "The vault's strategy"
  strategy: BeefyStrategy!

  "Technical field to remember if the vault was already initialized"
  isInitialized: Boolean!

  "The current lifecycle status of the vault"
  lifecycle: VaultLifecycle!

  "The underlying platform this vault is using"
  underlyingPlatform: VaultUnderlyingPlatform!

  "The vault's total shares supply as represented in the contract"
  rawSharesTokenTotalSupply: BigInt!

  "The vault's total shares supply"
  sharesTokenTotalSupply: BigDecimal!

  "how much underlying asset one vault share represents as represented in the contract"
  pricePerFullShare: BigInt!

  "how much underlying asset one vault share represents"
  shareToUnderlyingRate: BigDecimal!

  "vault total underlying balance as its represented in the contract"
  rawUnderlyingBalance: BigInt!

  "vault total underlying balance"
  underlyingBalance: BigDecimal!

  "positions in the vault"
  positions: [InvestorPosition!]! @derivedFrom(field: "vault")

  "breakdown of the vault underlying token balance"
  underlyingTokenBalanceBreakdown: [VaultBalanceBreakdown!]! @derivedFrom(field: "vault")

  "breakdown update events"
  underlyingTokenBalanceBreakdownUpdateEvents: [VaultBalanceBreakdownUpdateEvent!]! @derivedFrom(field: "vault")
}

"""
A strategy is a contract that manages the assets of a vault.
This is mostly used to start tracking the events and link them to the vault on new event
"""
type BeefyStrategy @entity {
  "The strategy address"
  id: Bytes!

  "The vault the strategy is managing"
  vault: BeefyVault!

  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

"""
A breakdown of the balance of a token
"""
type VaultBalanceBreakdown @entity {
  "Vault address this breakdown is for + token address of the breakdown item"
  id: Bytes!

  "vault address this breakdown is for"
  vault: BeefyVault!

  "Token address of the breakdown item"
  token: Token!

  "raw balance of the breakdown item as represented in the contract"
  rawBalance: BigInt!

  "Balance of the breakdown item"
  balance: BigDecimal!

  "last time the balance was updated"
  lastUpdateTimestamp: BigInt!

  "last time the balance was updated"
  lastUpdateBlock: BigInt!
}

"""
Remember the last time we updated the balance breakdown
so we can provide approx and exact balances
"""
type VaultBalanceBreakdownUpdateEvent @entity(immutable: true) {
  "Vault address + block number"
  id: Bytes!

  "Vault address that was updated"
  vault: BeefyVault

  "Block timestamp of the update"
  blockTimestamp: BigInt!
  "Block number of the update"
  blockNumber: BigInt!
}

type InvestorPosition @entity {
  "vault address + investor address"
  id: Bytes!

  "Investor address"
  investor: Investor!

  "Vault address"
  vault: BeefyVault!

  "Amount of shares"
  sharesBalance: BigDecimal!

  "Underlying balance"
  underlyingBalance: BigDecimal!

  "Breakdown of the investor position balance"
  balanceBreakdown: [InvestorPositionBalanceBreakdown!]! @derivedFrom(field: "investorPosition")

  # "Amount of underlying asset the investor is entitled to"
  # underlyingBalance: BigDecimal!

  # """
  # Time weighted balance up until the last time we updated the time weighted balance.
  # This is the balance times the amount of time the investor has held the token
  # ex: if the investor has held 100 tokens for 10 seconds, the time weighted balance is 1000
  # """
  # timeWeightedUnderlyingBalance: BigDecimal!

  # """
  # The last time we updated the time weighted balance
  # this can be used to calculate the time weighted balance at any block using:
  # timeWeightedUnderlyingBalance + balance * (block.timestamp - timeWeightedUnderlyingBalanceTimestamp)
  # """
  # timeWeightedUnderlyingBalanceTimestamp: BigInt!
}

type InvestorPositionBalanceBreakdown @entity {
  "Investor position id + token address"
  id: Bytes!

  "Investor position"
  investorPosition: InvestorPosition!

  "Token address of the breakdown item"
  token: Token

  "Balance of the breakdown item"
  balance: BigDecimal!

  "last time the balance was updated"
  lastUpdateTimestamp: BigInt!

  "last time the balance was updated"
  lastUpdateBlock: BigInt!
}
