"""
A investor is an address that interacts with our protocol.
"""
type Investor @entity {
  "User address"
  id: Bytes!

  "The investor's balances in all the tracked vaults"
  positions: [InvestorPosition!]! @derivedFrom(field: "investor")
}

"""
A token is a representation of a fungible asset on the blockchain
as specified by the ERC20 standard.
"""
type Token @entity(immutable: true) {
  "token address"
  id: Bytes!

  "The token symbol"
  symbol: String
  "The token name"
  name: String
  "The number of decimals the token uses"
  decimals: BigInt!

  "Breakdown of the balance of the token"
  balanceBreakdown: [BalanceBreakdownItem!]! @derivedFrom(field: "wrapperToken")
}

enum VaultLifecycle {
  "The vault is in the process of being initialized"
  INITIALIZING
  "The vault is able to accept deposits and earn yield"
  RUNNING
  "A vault can be paused for a variety of reasons, this is always to protect investors funds"
  PAUSED
}

enum VaultUnderlyingPlatform {
  PENDLE_EQUILIBRIA
  BALANCER_AURA
  MENDI
  AERODROME
  CURVE
  LYNEX_GAMMA
}

"""
A Beefy vault
"""
type BeefyVault @entity {
  "Vault address"
  id: Bytes!

  "Moo token address"
  sharesToken: Token!

  "Input lp token address"
  underlyingToken: Token!

  "The vault's strategy"
  strategy: BeefyStrategy!

  "Technical field to remember if the vault was already initialized"
  isInitialized: Boolean!

  "The current lifecycle status of the vault"
  lifecycle: VaultLifecycle!

  "The underlying platform this vault is using"
  underlyingPlatform: VaultUnderlyingPlatform!

  "how much underlying asset one vault share represents as represented in the contract"
  pricePerFullShare: BigInt!

  "how much underlying asset one vault share represents"
  shareToUnderlyingRate: BigDecimal!

  "vault total underlying balance"
  underlyingBalance: BigDecimal!

  "positions in the vault"
  positions: [InvestorPosition!]! @derivedFrom(field: "vault")
}

"""
A strategy is a contract that manages the assets of a vault.
This is mostly used to start tracking the events and link them to the vault on new event
"""
type BeefyStrategy @entity {
  "The strategy address"
  id: Bytes!

  "The vault the strategy is managing"
  vault: BeefyVault!

  "Technical field to remember if the strategy was already initialized"
  isInitialized: Boolean!
}

type InvestorPosition @entity {
  "vault address + investor address"
  id: Bytes!

  "Investor address"
  investor: Investor!

  "Vault address"
  vault: BeefyVault!

  "Amount of shares"
  sharesBalance: BigDecimal!

  # "Amount of underlying asset the investor is entitled to"
  # underlyingBalance: BigDecimal!

  # """
  # Time weighted balance up until the last time we updated the time weighted balance.
  # This is the balance times the amount of time the investor has held the token
  # ex: if the investor has held 100 tokens for 10 seconds, the time weighted balance is 1000
  # """
  # timeWeightedUnderlyingBalance: BigDecimal!

  # """
  # The last time we updated the time weighted balance
  # this is used to calculate the time weighted balance at any block using:
  # timeWeightedUnderlyingBalance + balance * (block.timestamp - timeWeightedUnderlyingBalanceTimestamp)
  # """
  # timeWeightedUnderlyingBalanceTimestamp: BigDecimal!
}

"""
A breakdown of the balance of a token
"""
type BalanceBreakdownItem @entity {
  "Token address this breakdown is for + token address of the breakdown item"
  id: Bytes!

  "Token address this breakdown is for"
  wrapperToken: Token!

  "Token address of the breakdown item"
  token: Token!

  "Balance of the breakdown item"
  balance: BigDecimal!

  "last time the balance was updated"
  lastUpdate: BigInt!
}
